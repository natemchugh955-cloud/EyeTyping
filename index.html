<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>Gaze Yes/No Sentence Writer</title>
  <style>
    :root{
      --bg:#0f172a; --panel:#111827; --ink:#e5e7eb; --muted:#9ca3af;
      --accent:#22d3ee; --ok:#4ade80; --warn:#fbbf24; --bad:#fb7185;
    }
    *{box-sizing:border-box} html,body{height:100%}
    body{margin:0;background:linear-gradient(180deg,#0b1023,var(--bg));color:var(--ink);
         font:400 16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;display:flex}
    .wrap{margin:auto; width:min(1100px,100%); padding:14px; display:grid; gap:14px;
          grid-template-columns: 1.15fr 1fr}
    @media (max-width:900px){ .wrap{grid-template-columns:1fr} }
    .card{background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);
          border-radius:18px;padding:14px;backdrop-filter:blur(6px);box-shadow:0 10px 30px rgba(0,0,0,.35)}
    h1{margin:0 0 6px;font-size:clamp(18px,2.8vw,26px)}
    .sub{margin:0 0 10px;color:var(--muted)}
    .stage{position:relative;width:100%;aspect-ratio:16/10;border-radius:14px;overflow:hidden;background:#0a0f22}
    video{display:none} canvas{width:100%;height:100%;background:#000}
    .hud{position:absolute;left:10px;bottom:10px;display:flex;gap:8px;flex-wrap:wrap}
    .btn{appearance:none;border:1px solid rgba(255,255,255,.14);background:#0b1229;color:var(--ink);
         border-radius:12px;padding:9px 12px;font-weight:600;cursor:pointer}
    .btn:hover{border-color:rgba(255,255,255,.28)}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .chip{background:#0b1229;border:1px dashed rgba(255,255,255,.15);border-radius:10px;padding:6px 10px}
    .big{font-size:clamp(30px,6vw,56px);font-weight:800;letter-spacing:.5px;margin:8px 0 0}
    .state-up{color:var(--ok)} .state-down{color:var(--bad)} .state-center{color:var(--warn)}
    .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;background:#0c1226;
         border:1px solid rgba(255,255,255,.1);padding:1px 5px;border-radius:6px}
    textarea.output{width:100%;min-height:140px;border-radius:12px;background:#0b1229;
                    border:1px solid rgba(255,255,255,.12);color:var(--ink);padding:10px 12px;
                    font-size:18px;resize:vertical}
    .q{font-size:20px;margin:8px 0 4px}
    .prompt{font-size:15px;color:var(--muted);margin:0 0 8px}
    .small{font-size:13px;color:var(--muted)}
    a{color:var(--accent);text-decoration:none}
  </style>
</head>
<body>
  <div class="wrap">
    <section class="card">
      <h1>Gaze-Driven Yes/No (Up=Yes, Down=No)</h1>
      <p class="sub">Hold <b>UP</b> for 3 seconds to start. Then answer prompts with your eyes:
        <span class="kbd">UP = Yes</span>, <span class="kbd">DOWN = No</span>. Everything runs locally in your browser.</p>

      <div class="stage">
        <video id="video" playsinline></video>
        <canvas id="canvas"></canvas>
        <div class="hud">
          <button class="btn" id="startBtn">‚ñ∂ Start Camera</button>
          <button class="btn" id="stopBtn">‚èπ Stop</button>
          <button class="btn" id="calBtn">üéØ Calibrate Neutral</button>
        </div>
      </div>

      <div class="row" style="margin-top:10px">
        <div class="chip">Left: <span id="lratio">‚Äî</span></div>
        <div class="chip">Right: <span id="rratio">‚Äî</span></div>
        <div class="chip">Avg: <span id="avg">‚Äî</span></div>
        <div class="chip">Neutral: <span id="neutral">‚Äî</span></div>
        <div class="chip">Band ¬± <span id="bandVal">0.10</span>
          <input id="band" type="range" min="0.05" max="0.25" step="0.01" value="0.10" style="vertical-align:middle;margin-left:6px">
        </div>
      </div>

      <div id="gazeState" class="big state-center">CENTER</div>
      <p class="small">Debug overlay shows eyelid line and iris point. Ensure good lighting.</p>
    </section>

    <aside class="card">
      <div class="q">Conversation</div>
      <div class="prompt" id="prompt">Idle. Look UP for 3s to begin.</div>
      <div class="row" style="gap:6px; margin-bottom:8px">
        <div class="chip">Yes hold: <span id="yesHold">0</span> ms</div>
        <div class="chip">No hold: <span id="noHold">0</span> ms</div>
      </div>
      <textarea id="sentence" class="output" placeholder="Your sentence will appear here‚Ä¶" spellcheck="false"></textarea>
      <div class="small" style="margin-top:8px">
        Flow: Idle ‚Üí ‚ÄúWrite a sentence?‚Äù ‚Üí If Yes: vowel? If vowel, ask A/E/I/O/U in order.
        If not vowel, test consonants in this order:
        <span class="kbd">T N S H R D L C M F W G Y P B V K X J Q Z</span>.
        Then predict from <span class="kbd">word.txt</span>. If not matched, keep adding letters.
      </div>
    </aside>
  </div>

  <!-- MediaPipe (FaceMesh + utils) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

  <script>
  /************ 1) Face + Iris ‚Üí Up/Down detector (same core as before) ************/
  const video  = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const ctx    = canvas.getContext('2d');

  const startBtn = document.getElementById('startBtn');
  const stopBtn  = document.getElementById('stopBtn');
  const calBtn   = document.getElementById('calBtn');

  const lratioEl = document.getElementById('lratio');
  const rratioEl = document.getElementById('rratio');
  const avgEl    = document.getElementById('avg');
  const neutralEl= document.getElementById('neutral');
  const stateEl  = document.getElementById('gazeState');

  const band     = document.getElementById('band');
  const bandVal  = document.getElementById('bandVal');

  const yesHoldEl = document.getElementById('yesHold');
  const noHoldEl  = document.getElementById('noHold');

  const promptEl  = document.getElementById('prompt');
  const sentenceEl= document.getElementById('sentence');

  let camera = null, running = false;
  let neutral = 0.5, bandWidth = parseFloat(band.value);
  band.addEventListener('input', ()=>{ bandWidth = parseFloat(band.value); bandVal.textContent = bandWidth.toFixed(2); });

  function setGazeLabel(text, cls){ stateEl.className = 'big '+cls; stateEl.textContent = text; }

  function avgPts(pts){ let sx=0, sy=0; for(const p of pts){sx+=p.x; sy+=p.y;} return {x:sx/pts.length, y:sy/pts.length}; }
  function dot(p){ ctx.beginPath(); ctx.arc(p.x*canvas.width, p.y*canvas.height, 3, 0, Math.PI*2); ctx.fill(); }

  function eyeRatio(lm, top, bottom, irisIdxs){
    const topP = lm[top], botP = lm[bottom];
    const iris = avgPts(irisIdxs.map(i=>lm[i]));
    // debug draw
    ctx.fillStyle = "#00e5ff"; dot(iris);
    ctx.beginPath();
    ctx.moveTo(topP.x*canvas.width, topP.y*canvas.height);
    ctx.lineTo(botP.x*canvas.width, botP.y*canvas.height);
    ctx.strokeStyle = "rgba(255,255,255,.35)"; ctx.lineWidth = 2; ctx.stroke();
    return ((iris.y - topP.y) / ((botP.y - topP.y) || 1e-6));
  }

  let faceMeshGlobal = null;
  function onResults(results){
    if(!running) return;
    canvas.width = results.image.width; canvas.height = results.image.height;
    ctx.drawImage(results.image,0,0,canvas.width,canvas.height);

    if(!results.multiFaceLandmarks || !results.multiFaceLandmarks.length){
      setGazeLabel("NO FACE","state-center");
      lratioEl.textContent=rratioEl.textContent=avgEl.textContent="‚Äî";
      updateDecision("center"); // keep timers from drifting
      return;
    }
    const lm = results.multiFaceLandmarks[0];
    const l = eyeRatio(lm,159,145,[468,469,470,471,472]);
    const r = eyeRatio(lm,386,374,[473,474,475,476,477]);
    const avg = (l+r)/2;

    lratioEl.textContent = l.toFixed(3);
    rratioEl.textContent = r.toFixed(3);
    avgEl.textContent    = avg.toFixed(3);
    neutralEl.textContent= neutral.toFixed(3);

    let status = "center";
    if (avg < neutral - bandWidth) { status = "down";   setGazeLabel("DOWN","state-down"); }
    else if (avg > neutral + bandWidth) { status = "up"; setGazeLabel("UP","state-up"); }
    else { setGazeLabel("CENTER","state-center"); }
    updateDecision(status);
  }

  function start(){
    if(running) return; running = true;
    const fm = new FaceMesh({locateFile:(f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`});
    fm.setOptions({maxNumFaces:1, refineLandmarks:true, minDetectionConfidence:.5, minTrackingConfidence:.5});
    fm.onResults(onResults);
    faceMeshGlobal = fm;

    camera = new Camera(video, { onFrame: async ()=>{ await fm.send({image:video}); }, width:640, height:400 });
    camera.start().catch(err=>{ alert("Camera error (needs HTTPS & permissions):\n\n"+err); running=false; });
  }
  function stop(){ running=false; if(camera){camera.stop(); camera=null;} setGazeLabel("STOPPED","state-center"); }
  async function calibrate(){
    if(!running) { alert("Start camera first."); return; }
    const snaps = [];
    const t0 = performance.now();
    while(performance.now()-t0 < 350){
      const res = await faceMeshGlobal; // wait next frame via onResults (already handles)
      // best-effort: neutral gets updated inside onResults; we‚Äôll read the last Avg shown
    }
    // Use currently displayed Avg as neutral (safer approach is to sample again; simple here):
    const a = parseFloat(avgEl.textContent);
    if(!Number.isNaN(a)) neutral = a;
    neutralEl.textContent = neutral.toFixed(3);
  }
  startBtn.onclick = start; stopBtn.onclick = stop; calBtn.onclick = calibrate;

  /************ 2) Yes/No timers + 3s activation ************/
  const YES_HOLD_MS = 1000; // hold UP for ‚â• this to say "Yes"
  const NO_HOLD_MS  = 1000; // hold DOWN for ‚â• this to say "No"
  const WAKE_MS     = 3000; // hold UP for ‚â• this to initiate from Idle

  let curStatus = "center", lastStatus = "center";
  let yesAccum = 0, noAccum = 0;   // running hold timers
  let lastTick = performance.now();

  function updateDecision(status){
    const now = performance.now();
    const dt = now - lastTick; lastTick = now;
    curStatus = status;

    if(status === "up"){ yesAccum += dt; noAccum = Math.max(0, noAccum - dt*0.5); }
    else if(status === "down"){ noAccum += dt; yesAccum = Math.max(0, yesAccum - dt*0.5); }
    else { yesAccum = Math.max(0, yesAccum - dt*0.75); noAccum = Math.max(0, noAccum - dt*0.75); }

    yesHoldEl.textContent = Math.floor(yesAccum);
    noHoldEl.textContent  = Math.floor(noAccum);

    // Activation from IDLE
    if(flow.state === "IDLE" && yesAccum >= WAKE_MS){
      yesAccum = 0; noAccum = 0;
      askWriteSentence();
      return;
    }

    // Regular decision
    if(yesAccum >= YES_HOLD_MS){ yesAccum = 0; noAccum = 0; flowYes(); }
    if(noAccum  >= NO_HOLD_MS ){ yesAccum = 0; noAccum = 0; flowNo();  }
  }

  /************ 3) Dictionary load (word.txt in repo root) ************/
  let WORDS = [];
  fetch('word.txt')
    .then(r=>r.text())
    .then(t=>{
      WORDS = t.split(/\r?\n/).map(s=>s.trim().toLowerCase()).filter(Boolean);
      // A simple sort: shorter then alpha; you can include a frequency file later.
      WORDS.sort((a,b)=> a.length-b.length || a.localeCompare(b));
    })
    .catch(()=>{ console.warn('Could not load word.txt'); });

  /************ 4) Sentence Writer Flow (finite state machine) ************/
  const VOWELS = ['A','E','I','O','U'];
  const CONSONANTS = ["T","N","S","H","R","D","L","C","M","F","W","G","Y","P","B","V","K","X","J","Q","Z"];

  const flow = {
    state: "IDLE",
    wordPrefix: "",
    askIndex: 0,        // for stepping through A,E,I,O,U or consonant list
    preds: [],
    predIndex: 0
  };

  function setPrompt(s){ promptEl.textContent = s; }

  function resetToIdle(){
    flow.state = "IDLE"; flow.wordPrefix=""; flow.askIndex=0; flow.preds=[]; flow.predIndex=0;
    setPrompt("Idle. Look UP for 3s to begin.");
  }

  function askWriteSentence(){
    flow.state = "ASK_WRITE";
    setPrompt('Would you like to write a sentence? (UP=Yes, DOWN=No)');
  }

  function startWord(){
    flow.wordPrefix = "";
    flow.askIndex = 0;
    flow.state = "ASK_VOWEL_Q";
    setPrompt('Does the first letter start with a vowel? (UP=Yes, DOWN=No)');
  }

  function askVowelLetter(){
    flow.state = "ASK_VOWEL_LETTER";
    if (flow.askIndex >= VOWELS.length){
      // If we reached here, vowels were all ‚ÄúNo‚Äù ‚Üí consonant branch
      flow.askIndex = 0;
      return askConsonantLetter();
    }
    const L = VOWELS[flow.askIndex];
    setPrompt(`Is the letter "${L}"? (UP=Yes, DOWN=No)`);
  }

  function askConsonantLetter(){
    flow.state = "ASK_CONS_LETTER";
    if (flow.askIndex >= CONSONANTS.length){
      // None selected ‚Üí treat as new word, per your rule
      setPrompt("No letter selected. Treat as a new word. Start again? (UP=Yes, DOWN=No)");
      flow.state = "RESTART_OR_IDLE";
      return;
    }
    const L = CONSONANTS[flow.askIndex];
    setPrompt(`Is the letter "${L}"? (UP=Yes, DOWN=No)`);
  }

  function commitLetter(ch){
    flow.wordPrefix += ch.toLowerCase();
    // After a letter, try predictions
    flow.preds = WORDS.filter(w => w.startsWith(flow.wordPrefix));
    flow.predIndex = 0;
    if (flow.preds.length === 0){
      // None predicted yet ‚Üí keep adding letters (ask vowel/consonant again)
      flow.askIndex = 0;
      flow.state = "ASK_VOWEL_Q";
      setPrompt(`No words yet for "${flow.wordPrefix}". Next letter a vowel? (UP=Yes, DOWN=No)`);
    } else {
      askPrediction();
    }
  }

  function askPrediction(){
    flow.state = "ASK_PREDICT";
    if (flow.predIndex >= flow.preds.length){
      // Exhausted predictions ‚Üí ask to add another letter
      flow.askIndex = 0;
      flow.state = "ASK_VOWEL_Q";
      setPrompt(`No match chosen. Add another letter? Vowel? (UP=Yes, DOWN=No)`);
      return;
    }
    const word = flow.preds[flow.predIndex];
    setPrompt(`Is the word "${word}"? (UP=Yes, DOWN=No)`);
  }

  function acceptWord(word){
    const text = sentenceEl.value.trim();
    sentenceEl.value = (text ? text + ' ' : '') + word;
    // Ask to add another word to the sentence
    flow.state = "ASK_ANOTHER_WORD";
    setPrompt('Add another word? (UP=Yes, DOWN=No)');
  }

  /************ 5) Flow transitions on Yes/No ************/
  function flowYes(){
    switch(flow.state){
      case "IDLE":
        // handled by activation hold, but safe fallback
        askWriteSentence(); break;
      case "ASK_WRITE":
        startWord(); break;

      case "ASK_VOWEL_Q":
        flow.askIndex = 0; askVowelLetter(); break;

      case "ASK_VOWEL_LETTER": {
        const L = VOWELS[flow.askIndex]; commitLetter(L); break;
      }
      case "ASK_CONS_LETTER": {
        const L = CONSONANTS[flow.askIndex]; commitLetter(L); break;
      }

      case "ASK_PREDICT": {
        const word = flow.preds[flow.predIndex];
        acceptWord(word);
        break;
      }

      case "ASK_ANOTHER_WORD":
        // Start another word
        startWord(); break;

      case "RESTART_OR_IDLE":
        // restart new word
        startWord(); break;

      default: break;
    }
  }

  function flowNo(){
    switch(flow.state){
      case "ASK_WRITE":
        resetToIdle(); break;

      case "ASK_VOWEL_Q":
        // Not a vowel ‚Üí go to consonant list from the top
        flow.askIndex = 0; askConsonantLetter(); break;

      case "ASK_VOWEL_LETTER":
        flow.askIndex++; askVowelLetter(); break;

      case "ASK_CONS_LETTER":
        flow.askIndex++; askConsonantLetter(); break;

      case "ASK_PREDICT":
        flow.predIndex++; askPrediction(); break;

      case "ASK_ANOTHER_WORD":
        // Finish sentence ‚Üí go idle
        resetToIdle(); break;

      case "RESTART_OR_IDLE":
        // No ‚Üí idle
        resetToIdle(); break;

      default: /* ignore */ break;
    }
  }

  // Initialize display
  resetToIdle();

  // Mobile: ensure autoplay-friendly
  document.addEventListener('touchstart', ()=>{ if(video) video.muted = true; }, {passive:true});
  </script>
</body>
</html>




