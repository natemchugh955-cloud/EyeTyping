<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Eye Typing Mobile-Friendly</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  body { font-family: Arial, sans-serif; text-align:center; padding:12px; max-width:500px; margin:auto; }
  h1 { font-size:28px; margin-bottom:12px; }
  #prompt { font-size:20px; margin:16px 0; min-height:50px; }
  #output { font-size:18px; margin:12px 0; word-break:break-word; }
  #predictions { font-size:16px; margin:12px 0; color:#222; }
  #status { font-size:14px; color:#333; margin:8px 0; }
  button { font-size:20px; padding:12px 20px; margin:6px; border:none; border-radius:8px; cursor:pointer; transition:0.15s; }
  #yesBtn { background:#28a745; color:#fff; }
  #noBtn { background:#dc3545; color:#fff; }
  #resetBtn { background:#ff9800; color:#fff; }
  #finishBtn { background:#6f42c1; color:#fff; }
  .calib { background:#444; color:#fff; font-size:18px; }
  #webcam { display:none; width:100%; max-width:320px; border-radius:6px; margin-top:12px; }
  .indicator { display:inline-block; width:14px; height:14px; border-radius:50%; margin-left:8px; vertical-align:middle; }
  .green { background: #28a745; } .red { background:#dc3545; } .gray { background:#bbb; }
  .small { font-size:13px; color:#555; margin-top:8px; }
</style>
</head>
<body>
<h1>Eye Typing Prototype</h1>

<div id="prompt">Would you like to start? (YES/NO)</div>

<div id="output"></div>
<div id="predictions"></div>

<div>
  <button id="yesBtn">YES</button>
  <button id="noBtn">NO</button>
</div>

<div style="margin-top:12px;">
  <button id="calUp" class="calib">Calibrate Up</button>
  <button id="calDown" class="calib">Calibrate Down</button>
  <span id="detectorStatus">Detector: <span id="detState">OFF</span> 
  <span id="detIndicator" class="indicator gray"></span></span>
</div>

<div id="status" aria-live="polite"></div>
<div class="small">Use calibration before relying on eye control. Buttons always work as a fallback.</div>

<video id="webcam" autoplay playsinline></video>

<!-- MediaPipe -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/* =================== Word prediction logic =================== */
const vowels=["A","E","I","O","U"];
const consonants=["T","N","S","H","R","D","L","C","M","W","F","G","Y","P","B","V","J","K","X","Q","Z"];

let dictionary=["a","i","the","to","and","it","is","in","you","that","he","was","for","on","are","with","as","his","they","be","at","one"];
const stored=JSON.parse(localStorage.getItem("customWords")||"[]");
dictionary=dictionary.concat(stored);

let sentence="", currentWord="", step="askStart", letterIndex=0, predictedLetters=[], predictedIndex=0;

/* DOM */
const promptEl=document.getElementById('prompt');
const statusEl=document.getElementById('status');
const outputEl=document.getElementById('output');
const predsEl=document.getElementById('predictions');
const yesBtn=document.getElementById('yesBtn');
const noBtn=document.getElementById('noBtn');
const resetBtn=document.getElementById('resetBtn');
const finishBtn=document.getElementById('finishBtn');
const calUpBtn=document.getElementById('calUp');
const calDownBtn=document.getElementById('calDown');
const detStateEl=document.getElementById('detState');
const detIndicator=document.getElementById('detIndicator');

/* Helpers */
function updatePrompt(t){ promptEl.innerText=t; }
function updateStatus(t){ statusEl.innerText=t; }
function updateOutput(){
  outputEl.innerHTML=`<strong>Sentence:</strong> ${sentence.trim()}<br/><strong>Current word:</strong> ${currentWord}`;
  predsEl.innerHTML=predictedLetters.length?`<strong>Predicted next letters:</strong> ${predictedLetters.join(', ')}`:'';
}
function toLower(s){ return s?s.toLowerCase():s; }
function computePredictedLetters(prefix){
  const p=toLower(prefix), freq={};
  for(const w of dictionary) if(w.startsWith(p) && w.length>p.length){
    const next=w[p.length].toUpperCase();
    freq[next]=(freq[next]||0)+1;
  }
  return Object.entries(freq).sort((a,b)=>b[1]-a[1]||a[0].localeCompare(b[0])).map(e=>e[0]);
}
function isExactWord(prefix){ return dictionary.includes(toLower(prefix)); }
function addWordToDictionary(word){
  word=toLower(word);
  if(!dictionary.includes(word)){
    dictionary.push(word);
    let custom=JSON.parse(localStorage.getItem("customWords")||"[]");
    custom.push(word);
    localStorage.setItem("customWords",JSON.stringify(custom));
    updateStatus(`Added new word "${word}" to dictionary.`);
  }
}
function speakSentence(text){
  if('speechSynthesis' in window){
    const u=new SpeechSynthesisUtterance(text); window.speechSynthesis.speak(u);
  } else updateStatus("Speech not supported.");
}

/* Core flow */
function showNextLetter(){
  const list=(step==="vowel")?vowels:(step==="consonant")?consonants:[];
  if(letterIndex<list.length) updatePrompt("Letter: "+list[letterIndex]+" ?");
  else { step="askVowel"; updatePrompt("Reached end of list. Is it a vowel?"); }
}
function addLetter(letter){
  currentWord+=letter; updateStatus("Added letter: "+letter); updateOutput();
  if(isExactWord(currentWord)){
    predictedLetters=computePredictedLetters(currentWord); predictedIndex=0;
    step="askNextWord"; updatePrompt(`Word is "${currentWord}". Next word? (YES to accept / NO to continue spelling)`); updateOutput(); return;
  }
  predictedLetters=computePredictedLetters(currentWord); predictedIndex=0;
  if(predictedLetters.length>0){ step="predictLetter"; updatePrompt(`Is next letter "${predictedLetters[predictedIndex]}"?`); }
  else { step="askVowel"; updatePrompt("No predictions. Is it a vowel?"); }
  updateOutput();
}

function handleYes(){
  switch(step){
    case "askStart": step="askVowel"; updatePrompt("Is it a vowel?"); break;
    case "askVowel": step="vowel"; letterIndex=0; showNextLetter(); break;
    case "vowel": addLetter(vowels[letterIndex]); break;
    case "consonant": addLetter(consonants[letterIndex]); break;
    case "predictLetter": if(predictedLetters[predictedIndex]) addLetter(predictedLetters[predictedIndex]); else { step="askVowel"; updatePrompt("Prediction missing. Is it a vowel? "); } break;
    case "askNextWord":
      sentence+=currentWord+" ";
      if(!dictionary.includes(currentWord.toLowerCase())) addWordToDictionary(currentWord);
      currentWord=""; predictedLetters=[]; predictedIndex=0;
      step="askVowel"; updatePrompt("Next word? (YES = vowel, NO = consonant)"); updateOutput(); break;
    default: updateStatus("Unhandled YES: "+step);
  }
}
function handleNo(){
  switch(step){
    case "askStart": step="idle"; updatePrompt("Not starting."); break;
    case "askVowel": step="consonant"; letterIndex=0; showNextLetter(); break;
    case "vowel":
    case "consonant": letterIndex++; showNextLetter(); break;
    case "predictLetter": predictedIndex++; if(predictedIndex<predictedLetters.length) updatePrompt(`Is next letter "${predictedLetters[predictedIndex]}"? `); else { predictedLetters=[]; predictedIndex=0; step="askVowel"; updatePrompt("No more predicted letters. Is it a vowel?"); } break;
    case "askNextWord": if(!predictedLetters || predictedLetters.length===0){ predictedLetters=computePredictedLetters(currentWord); predictedIndex=0; } if(predictedLetters.length>0){ step="predictLetter"; updatePrompt(`Is next letter "${predictedLetters[predictedIndex]}"?`); } else { step="askVowel"; updatePrompt("No predictions. Is it a vowel? "); } break;
    default: updateStatus("Unhandled NO: "+step);
  }
  updateOutput();
}

/* Button hooks */
yesBtn.addEventListener('click',()=>{ handleYes(); });
noBtn.addEventListener('click',()=>{ handleNo(); });
finishBtn?.addEventListener('click',()=>{
  if(sentence.trim()){ speakSentence(sentence.trim()); updateStatus("Speaking: "+sentence.trim()); sentence=""; currentWord=""; step="idle"; predictedLetters=[]; predictedIndex=0; updateOutput(); }
  else updateStatus("No sentence to speak.");
});

/* =================== MediaPipe FaceMesh =================== */
const videoElement=document.getElementById('webcam');
let camera=null, faceMesh=null, calibUpVal=null, calibDownVal=null, detectorOn=false, lastTriggerTime=0;
const TRIGGER_COOLDOWN=900;

function setDetectorState(on){ detectorOn=on; detStateEl.innerText=on?"ON":"OFF"; detIndicator.className="indicator "+(on?"green":"gray"); }
function computeEyeNoseDelta(lm){ if(!lm || lm.length<400) return null; const leftCenterY=(lm[159].y+lm[145].y)/2; const rightCenterY=(lm[386].y+lm[374].y)/2; const noseY=lm[1].y; return ((leftCenterY+rightCenterY)/2 - noseY); }

function onResults(results){
  if(!detectorOn) return;
  const delta = computeEyeNoseDelta(results.multiFaceLandmarks?.[0]);
  if(delta===null) return;
  if(calibUpVal===null || calibDownVal===null) return;
  const mid=(calibUpVal+calibDownVal)/2;
  const range=(calibUpVal-calibDownVal)/2;
  const upThresh=mid+range*0.15;
  const downThresh=mid-range*0.15;
  const now=Date.now();
  if(delta>upThresh && now-lastTriggerTime>TRIGGER_COOLDOWN){ handleYes(); lastTriggerTime=now; detIndicator.className="indicator green"; detStateEl.innerText="LOOK UP → YES"; }
  else if(delta<downThresh && now-lastTriggerTime>TRIGGER_COOLDOWN){ handleNo(); lastTriggerTime=now; detIndicator.className="indicator red"; detStateEl.innerText="LOOK DOWN → NO"; }
  else { detIndicator.className="indicator gray"; detStateEl.innerText="IDLE"; }
}

async function startCamera(){
  faceMesh=new FaceMesh({locateFile:(file)=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
  faceMesh.setOptions({maxNumFaces:1, refineLandmarks:true, minDetectionConfidence:0.7, minTrackingConfidence:0.7});
  faceMesh.onResults(onResults);
  camera=new Camera(videoElement,{onFrame:async()=>{await faceMesh.send({image:videoElement});}, width:320, height:240});
  camera.start(); setDetectorState(true);
}

/* Calibration */
calUpBtn.addEventListener('click',()=>{ calibUpVal=Math.random(); updateStatus("Calibrate Up clicked (simulate)"); });
calDownBtn.addEventListener('click',()=>{ calibDownVal=Math.random(); updateStatus("Calibrate Down clicked (simulate)"); });

/* Init */
startCamera();
updateOutput();
</script>
</body>
</html>




