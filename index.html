<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Eye Controlled Predictive Text</title>
  <style>
    body { font-family: Arial, sans-serif; text-align: center; background: #f4f4f4; }
    #output { margin: 20px; font-size: 20px; font-weight: bold; }
    button { font-size: 18px; padding: 10px 20px; margin: 10px; border-radius: 8px; cursor: pointer; }
    #yesBtn { background: #4CAF50; color: white; }
    #noBtn { background: #F44336; color: white; }
    #predictions { margin: 20px; font-size: 16px; }
    video { display: none; }
    canvas { display: none; }
  </style>
</head>
<body>
  <h1>Eye Controlled Predictive Text</h1>
  <div id="output">Output: </div>
  <div id="predictions">Predictions: </div>
  <button id="yesBtn">YES (Look Up)</button>
  <button id="noBtn">NO (Look Down)</button>

  <video id="video" autoplay playsinline width="640" height="480"></video>
  <canvas id="canvas" width="640" height="480"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script>
    // --- Predictive Text Setup ---
    const dictionary = ["hi", "hello", "how", "are", "you", "cook", "dinner", "nick", "tell", "tree", "christmas", "presents"];
    let currentWord = "";
    let output = "";
    let predictions = [];
    let askingWordEnd = false;

    const outputDiv = document.getElementById("output");
    const predictionsDiv = document.getElementById("predictions");

    function updateDisplay() {
      outputDiv.textContent = "Output: " + output + currentWord;
      predictionsDiv.textContent = "Predictions: " + predictions.join(", ");
    }

    function predictNextLetters(prefix) {
      let letters = new Set();
      dictionary.forEach(word => {
        if (word.startsWith(prefix) && word.length > prefix.length) {
          letters.add(word[prefix.length]);
        }
      });
      return Array.from(letters);
    }

    function nextPrediction() {
      if (currentWord === "") {
        predictions = ["t", "n", "s"]; // start letters cycle
      } else {
        predictions = predictNextLetters(currentWord);
      }
      if (predictions.length === 0 && currentWord !== "") {
        // ask if this is the word
        predictions = ["[END WORD?]"];
        askingWordEnd = true;
      } else {
        askingWordEnd = false;
      }
      updateDisplay();
    }

    function confirmPrediction() {
      if (askingWordEnd) {
        output += currentWord + " ";
        currentWord = "";
        askingWordEnd = false;

        // Ask if sentence should end
        predictions = ["[END SENTENCE?]"];
        askingWordEnd = "sentence";
      } else if (askingWordEnd === "sentence") {
        output = output.trim() + ". ";
        currentWord = "";
        askingWordEnd = false;
        predictions = [];

        // Speak sentence aloud
        let utter = new SpeechSynthesisUtterance(output.trim());
        speechSynthesis.speak(utter);
      } else if (predictions.length > 0) {
        currentWord += predictions[0];
      }
      nextPrediction();
    }

    function denyPrediction() {
      if (askingWordEnd) {
        predictions = [];
        askingWordEnd = false;
        nextPrediction();
      } else if (predictions.length > 1) {
        predictions.shift();
      }
      updateDisplay();
    }

    document.getElementById("yesBtn").addEventListener("click", confirmPrediction);
    document.getElementById("noBtn").addEventListener("click", denyPrediction);

    nextPrediction();

    // --- Eye Tracking Setup with Frame Counter ---
    const videoElement = document.getElementById("video");
    const canvasElement = document.getElementById("canvas");
    const canvasCtx = canvasElement.getContext("2d");

    let lookingUpFrames = 0;
    let lookingDownFrames = 0;
    const REQUIRED_FRAMES = 10; // must look up/down for 10 frames in a row

    function onResults(results) {
      if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
        const landmarks = results.multiFaceLandmarks[0];

        // Eyes: use average Y of top vs bottom of face
        const leftEye = landmarks[159]; // upper eyelid
        const rightEye = landmarks[386];
        const nose = landmarks[1];

        const eyeY = (leftEye.y + rightEye.y) / 2;
        const noseY = nose.y;

        if (eyeY < noseY - 0.05) {
          lookingUpFrames++;
          lookingDownFrames = 0;
          if (lookingUpFrames >= REQUIRED_FRAMES) {
            confirmPrediction();
            lookingUpFrames = 0;
          }
        } else if (eyeY > noseY + 0.05) {
          lookingDownFrames++;
          lookingUpFrames = 0;
          if (lookingDownFrames >= REQUIRED_FRAMES) {
            denyPrediction();
            lookingDownFrames = 0;
          }
        } else {
          lookingUpFrames = 0;
          lookingDownFrames = 0;
        }
      }
    }

    const faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
    faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    faceMesh.onResults(onResults);

    const camera = new Camera(videoElement, {
      onFrame: async () => { await faceMesh.send({image: videoElement}); },
      width: 640, height: 480
    });
    camera.start();
  </script>
</body>
</html>










