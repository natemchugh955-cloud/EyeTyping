<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Eye Controlled Text Input</title>
  <style>
    body { font-family: Arial, sans-serif; background: #222; color: #eee; text-align: center; }
    #controls button { padding: 10px 20px; margin: 5px; border-radius: 8px; font-size: 16px; }
    #yesBtn { background: #4CAF50; color: white; }
    #noBtn { background: #f44336; color: white; }
    #calibrateUpBtn { background: #2196F3; color: white; }
    #calibrateDownBtn { background: #FF9800; color: white; }
    #prediction { margin-top: 20px; font-size: 18px; }
    #output { margin-top: 20px; font-size: 20px; font-weight: bold; }
    #debug { margin-top: 20px; font-size: 14px; white-space: pre-line; background: #333; padding: 10px; border-radius: 10px; }
    video { margin-top: 10px; border: 2px solid #555; border-radius: 8px; }
  </style>
</head>
<body>
  <h1>Eye Controlled Text Input</h1>
  <video id="video" width="320" height="240" autoplay muted></video>
  <div id="controls">
    <button id="yesBtn">Yes (Look Up)</button>
    <button id="noBtn">No (Look Down)</button>
    <button id="calibrateUpBtn">Calibrate Up</button>
    <button id="calibrateDownBtn">Calibrate Down</button>
  </div>
  <div id="prediction"></div>
  <div id="output"></div>
  <div id="debug"></div>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/facemesh"></script>

  <script>
    const HOLD_FRAMES = 10; // number of frames look must be held
    const COOLDOWN = 30;    // frames before another input can trigger

    let words = [];
    let currentWord = "";
    let currentSentence = "";
    let predictions = [];
    let lastAction = null;
    let cooldownCounter = 0;

    // Eye detection stability
    let upCounter = 0, downCounter = 0, neutralCounter = 0;
    let lastDirection = "NEUTRAL";

    // Calibration values
    let calibrateUpValue = null;
    let calibrateDownValue = null;

    // Debug info
    function logDebug(msg) {
      document.getElementById("debug").innerText += msg + "\n";
    }

    // Load dictionary
    async function loadDictionary() {
      try {
        const res = await fetch("words.txt");
        const text = await res.text();
        words = text.split(/\r?\n/).filter(w => w.trim().length > 0);
        logDebug(`Loaded ${words.length} words into dictionary`);
      } catch (e) {
        logDebug("Could not load dictionary: " + e);
      }
    }

    // Update UI
    function updateUI() {
      document.getElementById("output").innerText =
        `Sentence: ${currentSentence}\nWord: ${currentWord}`;
      document.getElementById("prediction").innerText =
        predictions.length > 0 ? "Predictions: " + predictions.join(", ") : "";
    }

    // Handle YES/NO input
    function handleInput(isYes) {
      if (cooldownCounter > 0) return;
      cooldownCounter = COOLDOWN;

      if (isYes) {
        currentWord += predictions[0] || "";
        logDebug("YES → added letter: " + (predictions[0] || ""));
      } else {
        predictions.shift();
        logDebug("NO → skipping, next predictions: " + predictions.join(", "));
      }

      if (predictions.length === 0) {
        // Word finished
        currentSentence += currentWord + " ";
        currentWord = "";
        logDebug("Word committed. Sentence so far: " + currentSentence);
        predictNext();
      }

      updateUI();
    }

    // Predict next letters
    function predictNext() {
      if (currentWord.length === 0) {
        predictions = "tnshrdlcumwfgypbvkjxqz".split(""); // start letters
      } else {
        const candidates = words.filter(w => w.startsWith(currentWord.toLowerCase()));
        const nextLetters = new Set();
        for (let w of candidates) {
          if (w.length > currentWord.length) {
            nextLetters.add(w[currentWord.length]);
          }
        }
        predictions = [...nextLetters];
        if (predictions.length === 0) {
          predictions = ["?"];
        }
      }
      logDebug("Predictions: " + predictions.join(", "));
      updateUI();
    }

    // Eye detection setup
    async function setupCamera() {
      const video = document.getElementById("video");
      const stream = await navigator.mediaDevices.getUserMedia({ video: true });
      video.srcObject = stream;
      return new Promise(resolve => {
        video.onloadedmetadata = () => resolve(video);
      });
    }

    function detectDirection(delta) {
      if (calibrateUpValue === null || calibrateDownValue === null) return "NEUTRAL";
      const mid = (calibrateUpValue + calibrateDownValue) / 2;
      if (delta < mid) return "UP";
      if (delta > mid) return "DOWN";
      return "NEUTRAL";
    }

    async function runFaceMesh() {
      const video = await setupCamera();
      const model = await facemesh.load();

      async function frameLoop() {
        cooldownCounter = Math.max(0, cooldownCounter - 1);

        const predictionsMesh = await model.estimateFaces({ input: video });
        if (predictionsMesh.length > 0) {
          const keypoints = predictionsMesh[0].scaledMesh;
          const eyeY = (keypoints[159][1] + keypoints[386][1]) / 2; // avg eyes
          const noseY = keypoints[1][1]; // nose tip
          const delta = noseY - eyeY;

          const direction = detectDirection(delta);

          // Count consecutive frames
          if (direction === "UP") {
            upCounter++; downCounter = 0; neutralCounter = 0;
          } else if (direction === "DOWN") {
            downCounter++; upCounter = 0; neutralCounter = 0;
          } else {
            neutralCounter++; upCounter = 0; downCounter = 0;
          }

          if (upCounter >= HOLD_FRAMES && lastDirection !== "UP") {
            logDebug(`Detected UP for ${HOLD_FRAMES} frames → YES`);
            handleInput(true);
            lastDirection = "UP";
          } else if (downCounter >= HOLD_FRAMES && lastDirection !== "DOWN") {
            logDebug(`Detected DOWN for ${HOLD_FRAMES} frames → NO`);
            handleInput(false);
            lastDirection = "DOWN";
          } else if (neutralCounter >= HOLD_FRAMES) {
            lastDirection = "NEUTRAL";
          }

          logDebug(`delta=${delta.toFixed(2)}, direction=${direction}`);
        } else {
          logDebug("No face detected");
        }

        requestAnimationFrame(frameLoop);
      }

      frameLoop();
    }

    // Event listeners for manual testing
    document.getElementById("yesBtn").onclick = () => handleInput(true);
    document.getElementById("noBtn").onclick = () => handleInput(false);
    document.getElementById("calibrateUpBtn").onclick = () => {
      calibrateUpValue = parseFloat(prompt("Look UP and enter delta value shown in debug:"));
      logDebug("Calibrated UP value = " + calibrateUpValue);
    };
    document.getElementById("calibrateDownBtn").onclick = () => {
      calibrateDownValue = parseFloat(prompt("Look DOWN and enter delta value shown in debug:"));
      logDebug("Calibrated DOWN value = " + calibrateDownValue);
    };

    // Initialize
    loadDictionary().then(() => {
      predictNext();
      runFaceMesh();
    });
  </script>
</body>
</html>


