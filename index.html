<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Eye Typing Prototype — Predict Next Letter</title>
<style>
  body { font-family: Arial, sans-serif; text-align:center; padding:18px; max-width:720px; margin:auto;}
  h1 { font-size:20px; margin-bottom:6px; }
  #prompt { font-size:22px; margin:14px 0; min-height:56px; }
  #status { font-size:18px; color:#333; margin-top:6px; }
  #output { font-size:18px; margin-top:16px; word-break:break-word; }
  button { font-size:18px; padding:10px 18px; margin:8px; }
  .small { font-size:14px; color:#555; margin-top:6px; }
  #predictions { margin-top:10px; font-size:16px; color:#222; }
</style>
</head>
<body>
  <h1>Eye Typing Prototype — Predict Next Letter</h1>
  <div id="prompt">Press START to begin.</div>

  <div>
    <button id="yesBtn">YES (look up)</button>
    <button id="noBtn">NO (look down)</button>
    <button id="startBtn">START</button>
    <button id="resetBtn">RESET</button>
  </div>

  <div id="status" aria-live="polite"></div>
  <div id="output"></div>
  <div id="predictions"></div>
  <div class="small">Flow: Start → "Is it a vowel?" → pick letter from vowel/consonant order. After every letter the system predicts a list of possible next letters (most-likely first). If the typed token is a full dictionary word it will ask "Next word?" automatically.</div>

<script>
/* ====== Configuration ====== */
const vowels = ["A","E","I","O","U"];
const consonants = ["T","N","S","H","R","D","L","C","M","W","F","G","Y","P","B","V","J","K","X","Q","Z"];

/* ====== Runtime state ====== */
let dictionary = [];
let sentence = "";
let currentWord = "";
let step = "idle";           // idle | askStart | askVowel | vowel | consonant | predictLetter | askNextWord
let letterIndex = 0;         // index into vowels/consonants when scanning
let predictedLetters = [];   // ordered array of next-letter predictions (uppercase)
let predictedIndex = 0;      // index into predictedLetters

/* ====== DOM ====== */
const promptEl = document.getElementById('prompt');
const statusEl = document.getElementById('status');
const outputEl = document.getElementById('output');
const predsEl = document.getElementById('predictions');
const yesBtn = document.getElementById('yesBtn');
const noBtn = document.getElementById('noBtn');
const startBtn = document.getElementById('startBtn');
const resetBtn = document.getElementById('resetBtn');

/* ====== Helpers ====== */
function updatePrompt(t){ promptEl.innerText = t; }
function updateStatus(t){ statusEl.innerText = t; }
function updateOutput(){
  outputEl.innerHTML = `<strong>Sentence:</strong> ${sentence.trim()}<br/><strong>Current word:</strong> ${currentWord}`;
  predsEl.innerHTML = predictedLetters.length ? `<strong>Predicted next letters:</strong> ${predictedLetters.join(', ')}` : '';
}
function toLower(s){ return s ? s.toLowerCase() : s; }

/* compute next-letter predictions for a prefix */
function computePredictedLetters(prefix){
  const p = toLower(prefix);
  const freq = {};
  for(const w of dictionary){
    if(w.startsWith(p) && w.length > p.length){
      const next = w[p.length].toUpperCase();
      freq[next] = (freq[next] || 0) + 1;
    }
  }
  // sort by frequency desc, then alphabetically
  const arr = Object.entries(freq).sort((a,b) => b[1] - a[1] || a[0].localeCompare(b[0])).map(e => e[0]);
  return arr;
}

/* check if prefix is exact word in dictionary */
function isExactWord(prefix){
  return dictionary.includes(toLower(prefix));
}

/* ====== Core flows ====== */
function start(){
  sentence = "";
  currentWord = "";
  step = "askStart";
  predictedLetters = [];
  predictedIndex = 0;
  letterIndex = 0;
  updatePrompt("Start a new sentence? (YES to begin)");
  updateStatus("");
  updateOutput();
}

function resetAll(){
  sentence = "";
  currentWord = "";
  step = "idle";
  predictedLetters = [];
  predictedIndex = 0;
  letterIndex = 0;
  updatePrompt("Press START to begin.");
  updateStatus("Reset.");
  updateOutput();
}

/* show next letter in current vowel/consonant scan */
function showNextLetter(){
  const list = (step === "vowel") ? vowels : (step === "consonant") ? consonants : [];
  if(letterIndex < list.length){
    updatePrompt("Letter: " + list[letterIndex] + " ? (YES/NO)");
  } else {
    step = "askVowel";
    updatePrompt("Is it a vowel? (YES for vowels, NO for consonants)");
  }
}

/* add letter chosen by user (from scan or prediction) */
function addLetter(letter){
  currentWord += letter;
  updateStatus("Added letter: " + letter);
  updateOutput();

  if(isExactWord(currentWord)){
    predictedLetters = computePredictedLetters(currentWord);
    predictedIndex = 0;
    step = "askNextWord";
    updatePrompt(`Word is "${currentWord}". Next word? (YES to accept / NO to continue spelling)`);
    updateOutput();
    return;
  }

  predictedLetters = computePredictedLetters(currentWord);
  predictedIndex = 0;
  if(predictedLetters.length > 0){
    step = "predictLetter";
    updatePrompt(`Is next letter "${predictedLetters[predictedIndex]}"? (YES/NO)`);
  } else {
    step = "askVowel";
    letterIndex = 0;
    updatePrompt("No predictions. Is it a vowel? (YES/NO)");
  }
  updateOutput();
}

/* handle YES behavior depending on state */
function handleYes(){
  switch(step){
    case "askStart":
      step = "askVowel";
      updatePrompt("Is it a vowel? (YES for vowels, NO for consonants)");
      break;

    case "askVowel":
      step = "vowel";
      letterIndex = 0;
      showNextLetter();
      break;

    case "vowel":
      addLetter(vowels[letterIndex]);
      break;

    case "consonant":
      addLetter(consonants[letterIndex]);
      break;

    case "predictLetter":
      if(predictedLetters[predictedIndex]){
        addLetter(predictedLetters[predictedIndex]);
      } else {
        step = "askVowel";
        updatePrompt("Prediction missing. Is it a vowel? (YES/NO)");
      }
      break;

    case "askNextWord":
      sentence += currentWord + " ";
      currentWord = "";
      predictedLetters = [];
      predictedIndex = 0;
      step = "askVowel";
      updatePrompt("Next word? (YES = vowel set, NO = consonant set)");
      updateOutput();
      break;

    default:
      updateStatus("Unhandled YES in state: " + step);
  }
}

/* handle NO behavior depending on state */
function handleNo(){
  switch(step){
    case "askStart":
      step = "idle";
      updatePrompt("Okay — not starting. Press START to try again.");
      break;

    case "askVowel":
      step = "consonant";
      letterIndex = 0;
      showNextLetter();
      break;

    case "vowel":
    case "consonant":
      letterIndex++;
      showNextLetter();
      break;

    case "predictLetter":
      predictedIndex++;
      if(predictedIndex < predictedLetters.length){
        updatePrompt(`Is next letter "${predictedLetters[predictedIndex]}"? (YES/NO)`);
      } else {
        predictedLetters = [];
        predictedIndex = 0;
        step = "askVowel";
        updatePrompt("No more predicted letters. Is it a vowel? (YES/NO)");
      }
      break;

    case "askNextWord":
      if(!predictedLetters || predictedLetters.length === 0){
        predictedLetters = computePredictedLetters(currentWord);
        predictedIndex = 0;
      }
      if(predictedLetters.length > 0){
        step = "predictLetter";
        updatePrompt(`Is next letter "${predictedLetters[predictedIndex]}"? (YES/NO)`);
      } else {
        step = "askVowel";
        updatePrompt("No predictions. Is it a vowel? (YES/NO)");
      }
      break;

    default:
      updateStatus("Unhandled NO in state: " + step);
  }
  updateOutput();
}

/* event hookups */
yesBtn.addEventListener('click', () => { handleYes(); });
noBtn.addEventListener('click', () => { handleNo(); });
startBtn.addEventListener('click', () => { start(); });
resetBtn.addEventListener('click', () => { resetAll(); });

/* ====== Load large dictionary ====== */
async function loadDictionary(){
  try {
    const resp = await fetch("words.txt");
    const text = await resp.text();
    dictionary = text.split(/\r?\n/).map(w => w.trim().toLowerCase()).filter(w => w);
    console.log("Dictionary loaded:", dictionary.length, "words");
  } catch(e){
    console.error("Error loading dictionary:", e);
    dictionary = ["a","i","the","to","and","it","is","in","you","hello","hi"]; // fallback
  }
}

/* Initialize */
resetAll();
loadDictionary();
</script>
</body>
</html>




