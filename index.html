<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Eye Controlled Letter Predictor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <style>
    :root{
      --pad:14px;
    }
    *{box-sizing:border-box}
    body{
      font-family: system-ui, Arial, sans-serif;
      background:#f2f2f2;
      color:#111;
      margin:0;
      padding:0;
      text-align:center;
    }
    #app{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:12px;
      padding:var(--pad);
      max-width:720px;
      margin:0 auto;
    }
    .prompt{
      font-weight:700;
      /* scalable on phones */
      font-size: clamp(18px, 5vw, 28px);
      margin-top:6px;
    }
    .letter{
      width:100%;
      background:#fff;
      border:2px solid #333;
      border-radius:12px;
      padding:16px;
      /* big readable letter */
      font-size: clamp(40px, 14vw, 96px);
      line-height:1;
      min-height:1.2em;
    }
    .info{
      width:100%;
      background:#fff;
      border-radius:10px;
      padding:10px 12px;
      font-size: clamp(16px, 4.2vw, 20px);
      text-align:left;
    }
    .labels{
      font-weight:600;
    }
    .buttons{
      display:flex;
      gap:12px;
      width:100%;
    }
    button{
      flex:1 1 50%;
      padding:16px 14px;
      font-size: clamp(18px, 5vw, 22px);
      border:none;
      border-radius:12px;
      color:#fff;
      box-shadow: 0 2px 10px rgba(0,0,0,0.15);
      cursor:pointer;
      touch-action: manipulation;
    }
    .yes{ background:#2e7d32; }
    .no{ background:#c62828; }
    .cal{ background:#1565c0; }
    .cal.secondary{ background:#6f42c1; }
    .row{ display:flex; gap:12px; width:100%; }
    .row > button{ flex:1 1 50%; }

    /* Debug panel */
    #debug{
      width:100%;
      background:#0b0b0b;
      color:#0f0;
      text-align:left;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: clamp(12px, 3.5vw, 14px);
      border-radius:10px;
      padding:10px;
      white-space:pre-wrap;
      max-height:280px;
      overflow:auto;
    }
    /* Tiny live status chips */
    .chips{ display:flex; gap:8px; width:100%; flex-wrap:wrap; justify-content:center; }
    .chip{
      background:#fff;
      border:1px solid #ddd;
      border-radius:999px;
      padding:6px 10px;
      font-size: clamp(12px, 3.5vw, 14px);
    }

    /* Video preview (small) for alignment debugging */
    #webcamWrap{
      width:100%;
      display:flex;
      justify-content:center;
    }
    video{
      width:100%;
      max-width:360px;
      border-radius:10px;
      border:1px solid #ccc;
      display:none; /* set to block if you want to see the feed */
    }

    /* Controls row for sensitivity */
    .controls{
      display:flex; gap:10px; width:100%; align-items:center; justify-content:center; flex-wrap:wrap;
      background:#fff; border-radius:10px; padding:8px 10px; border:1px solid #e8e8e8;
      font-size: clamp(13px, 3.8vw, 15px);
    }
    .controls label{ display:flex; align-items:center; gap:6px; }
    .controls input[type="range"]{ width:150px; }
  </style>
</head>
<body>
  <div id="app">
    <div class="prompt" id="prompt">Would you like to start?</div>
    <div class="letter" id="letter">_</div>

    <div class="info">
      <div class="labels">Sentence:</div>
      <div id="sentence"></div>
    </div>

    <div class="info">
      <div class="labels">Predicted Next Letter:</div>
      <div id="prediction"></div>
    </div>

    <div class="buttons">
      <button class="yes" id="yesBtn">Yes</button>
      <button class="no" id="noBtn">No</button>
    </div>

    <div class="row">
      <button class="cal" id="calUpBtn">Calibrate Up</button>
      <button class="cal secondary" id="calDownBtn">Calibrate Down</button>
    </div>

    <div class="controls">
      <label>Hold Frames
        <input type="range" id="holdFrames" min="5" max="30" value="15">
        <span id="holdFramesVal">15</span>
      </label>
      <label>Sensitivity
        <input type="range" id="sens" min="5" max="40" value="15">
        <span id="sensVal">0.15</span>
      </label>
      <label><input type="checkbox" id="showVideo"> Show camera preview</label>
    </div>

    <div class="chips">
      <span class="chip" id="chipFace">Face: —</span>
      <span class="chip" id="chipState">Eye: —</span>
      <span class="chip" id="chipFPS">FPS: —</span>
      <span class="chip" id="chipHolds">Holds U/D: 0/0</span>
      <span class="chip" id="chipDelta">Δ: —</span>
      <span class="chip" id="chipThresh">↑/↓: — / —</span>
    </div>

    <div id="debug"></div>

    <div id="webcamWrap">
      <video id="webcam" autoplay playsinline></video>
    </div>
  </div>

  <!-- MediaPipe (FaceMesh + Camera utils) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
    /* ================= Dictionaries ================= */
    let dictionary = new Set();
    let customDictionary = new Set(); // session additions

    fetch("words.txt")
      .then(res => res.text())
      .then(text => {
        text.split(/\r?\n/).forEach(word => {
          if (word.trim()) dictionary.add(word.trim().toLowerCase());
        });
        logDebug(\`Loaded \${dictionary.size} words from words.txt\`);
      })
      .catch(() => {
        ["hello","hi","have","hope","good","great","you","yes","no"].forEach(w=>dictionary.add(w));
        logDebug("Failed to load words.txt; using fallback dictionary.");
      });

    function finalizeWordStoreIfNeeded(word){
      const lower = word.toLowerCase();
      if(!dictionary.has(lower) && !customDictionary.has(lower)){
        customDictionary.add(lower);
        logDebug(\`[DICT] Added new (session) word: "\${word}"\`);
      } else {
        logDebug(\`[DICT] Word already known: "\${word}"\`);
      }
    }

    /* ================= UI & State ================= */
    const promptEl = document.getElementById("prompt");
    const letterEl = document.getElementById("letter");
    const sentenceEl = document.getElementById("sentence");
    const predictionEl = document.getElementById("prediction");
    const debugEl = document.getElementById("debug");

    const yesBtn = document.getElementById("yesBtn");
    const noBtn  = document.getElementById("noBtn");
    const calUpBtn = document.getElementById("calUpBtn");
    const calDownBtn = document.getElementById("calDownBtn");

    const chipFace = document.getElementById("chipFace");
    const chipState = document.getElementById("chipState");
    const chipFPS = document.getElementById("chipFPS");
    const chipHolds = document.getElementById("chipHolds");
    const chipDelta = document.getElementById("chipDelta");
    const chipThresh = document.getElementById("chipThresh");

    function updateUI(prompt, letter, predicted){
      if(prompt !== undefined) promptEl.textContent = prompt;
      if(letter !== undefined) letterEl.textContent = letter || "_";
      sentenceEl.textContent = currentSentence;
      predictionEl.textContent = predicted || "";
    }
    function logDebug(msg){
      debugEl.innerHTML += msg + "\\n";
      debugEl.scrollTop = debugEl.scrollHeight;
    }

    let currentSentence = "";
    let currentWord = "";
    let step = "start";
    const vowels = ["A","E","I","O","U"];
    const consonants = ["T","N","S","H","R","D","L","C","M","F","W","G","Y","P","B","V","K","X","J","Q","Z"];
    let letterIndex = 0;
    let predictedLetters = [];
    let predictedIndex = 0;

    function isKnownWord(w){
      const lower = w.toLowerCase();
      return dictionary.has(lower) || customDictionary.has(lower);
    }

    function computePredictedLetters(prefix){
      const p = prefix.toLowerCase();
      const all = [...dictionary, ...customDictionary];
      const freq = {};
      for(const w of all){
        if(w.startsWith(p) && w.length > p.length){
          const ch = w[p.length].toUpperCase();
          freq[ch] = (freq[ch] || 0) + 1;
        }
      }
      return Object.entries(freq).sort((a,b)=>b[1]-a[1] || a[0].localeCompare(b[0])).map(([k])=>k);
    }

    function startFlow(){
      step="start";
      currentWord="";
      updateUI("Would you like to start?","_","");
    }

    function afterLetterAdded(){
      if(isKnownWord(currentWord)){
        step="askNextWord";
        predictedLetters=[];
        predictedIndex=0;
        updateUI(\`Word is "\${currentWord}". Next word?\`, currentWord.slice(-1).toUpperCase(), "");
        return;
      }
      predictedLetters = computePredictedLetters(currentWord);
      predictedIndex = 0;
      if(predictedLetters.length){
        step="predict";
        const p = predictedLetters[predictedIndex];
        updateUI(\`Is next letter "\${p}"?\`, p, p);
      }else{
        step="isVowel";
        letterIndex=0;
        updateUI("Does the next letter start with a vowel?","_","");
      }
    }

    function askNextVowel(){
      if(letterIndex < vowels.length){
        const L = vowels[letterIndex];
        updateUI(\`Is the letter \${L}?\`, L, "");
      }else{
        step="consonants";
        letterIndex=0;
        askNextConsonant();
      }
    }
    function askNextConsonant(){
      if(letterIndex < consonants.length){
        const L = consonants[letterIndex];
        updateUI(\`Is the letter \${L}?\`, L, "");
      }else{
        step="confirmEndWord";
        updateUI(\`End word "\${currentWord}"?\`, "✔", "");
      }
    }

    function handleYes(){
      switch(step){
        case "start":
          step="isVowel"; letterIndex=0;
          updateUI("Does it start with a vowel?","_","");
          break;
        case "isVowel":
          step="vowels"; letterIndex=0; askNextVowel();
          break;
        case "vowels":
          currentWord += vowels[letterIndex]; afterLetterAdded();
          break;
        case "consonants":
          currentWord += consonants[letterIndex]; afterLetterAdded();
          break;
        case "predict":
          if(predictedLetters[predictedIndex]){
            currentWord += predictedLetters[predictedIndex];
            afterLetterAdded();
          }else{
            step="isVowel"; letterIndex=0;
            updateUI("Does the next letter start with a vowel?","_","");
          }
          break;
        case "askNextWord":
          currentSentence += (currentSentence ? " " : "") + currentWord;
          currentWord = "";
          step="start";
          updateUI("Next word?","_","");
          break;
        case "confirmEndWord":
          currentSentence += (currentSentence ? " " : "") + currentWord;
          finalizeWordStoreIfNeeded(currentWord);
          currentWord="";
          step="start";
          updateUI("Next word?","_","");
          break;
      }
    }

    function handleNo(){
      switch(step){
        case "isVowel":
          step="consonants"; letterIndex=0; askNextConsonant();
          break;
        case "vowels":
          letterIndex++; askNextVowel();
          break;
        case "consonants":
          letterIndex++; askNextConsonant();
          break;
        case "predict":
          predictedIndex++;
          if(predictedIndex < predictedLetters.length){
            const p = predictedLetters[predictedIndex];
            updateUI(\`Is next letter "\${p}"?\`, p, p);
          }else{
            step="isVowel"; letterIndex=0;
            updateUI("No more predictions. Does the next letter start with a vowel?","_","");
          }
          break;
        case "askNextWord":
          // keep spelling this same word
          predictedLetters = computePredictedLetters(currentWord);
          predictedIndex = 0;
          if(predictedLetters.length){
            step="predict";
            const p = predictedLetters[predictedIndex];
            updateUI(\`Is next letter "\${p}"?\`, p, p);
          }else{
            step="isVowel"; letterIndex=0;
            updateUI("No predictions. Does the next letter start with a vowel?","_","");
          }
          break;
        case "confirmEndWord":
          // keep spelling
          step="isVowel"; letterIndex=0;
          updateUI("Keep spelling. Does the next letter start with a vowel?","_","");
          break;
      }
    }

    yesBtn.addEventListener("click", handleYes);
    noBtn.addEventListener("click", handleNo);

    /* ================== Eye Tracking with Debug ================== */
    const video = document.getElementById("webcam");
    const showVideo = document.getElementById("showVideo");
    const holdFramesInput = document.getElementById("holdFrames");
    const holdFramesVal = document.getElementById("holdFramesVal");
    const sensInput = document.getElementById("sens");
    const sensVal = document.getElementById("sensVal");

    let faceMesh, camera;
    let calibUp = null, calibDown = null;
    let lastTrigger = 0;
    let holdUp = 0, holdDown = 0;
    let FPS = 0, lastTS = performance.now();
    let deltaMA = []; // moving average buffer
    const SMOOTH_N = 5;

    function setFPS(){
      const now = performance.now();
      const dt = now - lastTS;
      lastTS = now;
      FPS = dt > 0 ? Math.round(1000/dt) : FPS;
    }

    function updateChips(direction, delta, upThresh, downThresh){
      chipFace.textContent = "Face: " + (direction ? "Detected" : "—");
      chipState.textContent = "Eye: " + (direction || "NEUTRAL");
      chipFPS.textContent = "FPS: " + (FPS || "—");
      chipHolds.textContent = `Holds U/D: ${holdUp}/${holdDown}`;
      chipDelta.textContent = "Δ: " + (delta!==null ? delta.toFixed(4) : "—");
      chipThresh.textContent = "↑/↓: " + (upThresh!==null ? upThresh.toFixed(4) : "—") + " / " + (downThresh!==null ? downThresh.toFixed(4) : "—");
    }

    function computeDelta(landmarks){
      // indices: upper/lower lids and nose tip
      const lt = landmarks[159], lb = landmarks[145];
      const rt = landmarks[386], rb = landmarks[374];
      const nose = landmarks[1] || landmarks[4];
      if(!lt||!lb||!rt||!rb||!nose) return null;
      const leftY  = (lt.y + lb.y) / 2;
      const rightY = (rt.y + rb.y) / 2;
      const eyeY = (leftY + rightY) / 2;
      return (nose.y - eyeY); // + when eyes are above nose (looking up)
    }

    function smoothedDelta(raw){
      if(raw===null) return null;
      deltaMA.push(raw);
      if(deltaMA.length>SMOOTH_N) deltaMA.shift();
      const avg = deltaMA.reduce((a,b)=>a+b,0)/deltaMA.length;
      return avg;
    }

    function thresholds(){
      if(calibUp===null || calibDown===null) return {up:null, down:null};
      const mid = (calibUp + calibDown) / 2;
      const range = Math.abs(calibUp - calibDown);
      const mult = Number(sensInput.value)/100; // 0.05..0.40
      return { up: mid + range*mult, down: mid - range*mult };
    }

    async function initFace(){
      faceMesh = new FaceMesh({ locateFile:(f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}` });
      faceMesh.setOptions({
        maxNumFaces:1, refineLandmarks:true,
        minDetectionConfidence:0.6, minTrackingConfidence:0.6
      });
      faceMesh.onResults(onResults);

      try{
        const stream = await navigator.mediaDevices.getUserMedia({video:true, audio:false});
        video.srcObject = stream;
      }catch(e){
        logDebug("Camera permission denied or unavailable.");
        return;
      }

      camera = new Camera(video, {
        onFrame: async () => { await faceMesh.send({image: video}); },
        width: 640, height: 480
      });
      camera.start();
    }

    function onResults(results){
      setFPS();

      if(!results.multiFaceLandmarks || results.multiFaceLandmarks.length===0){
        updateChips(null, null, null, null);
        return;
      }
      const lms = results.multiFaceLandmarks[0];
      const dRaw = computeDelta(lms);
      const d = smoothedDelta(dRaw);
      const {up, down} = thresholds();

      let dir = "NEUTRAL";
      const now = performance.now();
      const holdNeeded = Number(holdFramesInput.value);

      if(d!==null && up!==null && down!==null){
        if(d > up) { dir = "UP"; holdUp++; holdDown=0; }
        else if(d < down) { dir = "DOWN"; holdDown++; holdUp=0; }
        else { dir = "NEUTRAL"; holdUp=0; holdDown=0; }

        // trigger YES/NO when held enough frames and cooldown passed
        if(dir==="UP" && holdUp>=holdNeeded && now-lastTrigger>250){
          lastTrigger = now;
          logDebug("[EYE] YES (UP held)");
          handleYes();
          holdUp=0;
        }
        if(dir==="DOWN" && holdDown>=holdNeeded && now-lastTrigger>250){
          lastTrigger = now;
          logDebug("[EYE] NO (DOWN held)");
          handleNo();
          holdDown=0;
        }
      }
      updateChips(dir, d, up, down);
    }

    function calibrate(which){
      // Take a short burst average for better stability
      if(lastCalSample) return; // prevent overlapping
      sampleCalibration(which);
    }

    let lastCalSample = null;
    function sampleCalibration(which){
      lastCalSample = { which, samples:[], taken:0 };
      const target = lastCalSample;
      const take = () => {
        if(!deltaMA.length){ // wait until we have at least one delta
          requestAnimationFrame(take); return;
        }
        // use the most recent smoothed value
        const val = deltaMA[deltaMA.length-1];
        if(val!==null) target.samples.push(val);
        target.taken++;
        if(target.taken<20){
          setTimeout(take, 40); // ~20 samples over ~800ms
        }else{
          const avg = target.samples.reduce((a,b)=>a+b,0)/target.samples.length;
          if(which==="up"){ calibUp = avg; logDebug(`[CAL] UP = ${avg.toFixed(4)}`); }
          else { calibDown = avg; logDebug(`[CAL] DOWN = ${avg.toFixed(4)}`); }
          lastCalSample = null;
        }
      };
      take();
    }

    // UI control bindings
    holdFramesInput.addEventListener("input", ()=> holdFramesVal.textContent = holdFramesInput.value);
    sensInput.addEventListener("input", ()=> sensVal.textContent = (Number(sensInput.value)/100).toFixed(2));
    document.getElementById("showVideo").addEventListener("change", (e)=>{
      document.getElementById("webcam").style.display = e.target.checked ? "block" : "none";
    });

    document.getElementById("calUpBtn").addEventListener("click", ()=>calibrate("up"));
    document.getElementById("calDownBtn").addEventListener("click", ()=>calibrate("down"));

    // Buttons
    yesBtn.addEventListener("click", handleYes);
    noBtn.addEventListener("click", handleNo);

    /* ============ Start typing flow ============ */
    startFlow();

    /* ============ Init face tracking =========== */
    initFace();
  </script>
</body>
</html>



