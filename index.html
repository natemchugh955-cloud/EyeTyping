<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Eye Blink Sentence Builder</title>
  <style>
    body { font-family: Arial, sans-serif; text-align: center; margin-top: 40px; }
    #prompt { font-size: 2em; margin: 20px; }
    #current { font-size: 1.5em; margin-top: 10px; }
    #candidates { font-size: 1em; margin-top: 15px; color: #333; }
    #log { margin-top: 20px; font-size: 0.9em; color: gray; }
    button { font-size: 1.5em; margin: 10px; padding: 10px 20px; }
  </style>
</head>
<body>
  <h1>Eye Blink Sentence Builder</h1>
  <div id="prompt">Look up to start</div>
  <div id="current"></div>
  <div id="candidates"></div>
  <div id="log"></div>
  <button onclick="yes()">YES</button>
  <button onclick="no()">NO</button>

  <script>
    let words = [];
    let currentWord = "";
    let currentSentence = "";
    let predicting = false;

    // Letter groups
    const vowels = ["a", "e", "i", "o", "u"];
    const consonants = ["t","n","s","h","r","d","l","c","m","w","f","g","y","p","b","v","j","k","x","q","z"];

    // State machine
    let state = "start"; 
    let letterIndex = 0; // for cycling inside groups

    // Load dictionary
    fetch("words.txt")
      .then(res => res.text())
      .then(text => {
        words = text.split("\n").map(w => w.trim().toLowerCase()).filter(Boolean);
        document.getElementById("log").innerText = `Dictionary loaded: ${words.length} words`;
      })
      .catch(err => {
        console.error(err);
        document.getElementById("log").innerText = "❌ Failed to load words.txt";
      });

    function filterCandidates(prefix) {
      return words.filter(w => w.startsWith(prefix));
    }

    function predictNextLetter(prefix) {
      let candidates = filterCandidates(prefix);
      if (candidates.length === 0) return null;

      let freq = {};
      for (let w of candidates) {
        if (w.length > prefix.length) {
          let next = w[prefix.length];
          freq[next] = (freq[next] || 0) + 1;
        }
      }

      let sorted = Object.entries(freq).sort((a,b) => b[1] - a[1]);
      return sorted.length > 0 ? sorted[0][0] : null;
    }

    function updateDisplay(extra="") {
      document.getElementById("current").innerText = `Sentence: ${currentSentence} ${currentWord}`.trim();
      let cands = filterCandidates(currentWord).slice(0, 5);
      document.getElementById("candidates").innerText = cands.length > 0 
        ? "Candidates: " + cands.join(", ")
        : "⚠️ No candidates found";
      if (extra) document.getElementById("prompt").innerText = extra;
    }

    function yes() {
      if (state === "start") {
        state = "vowelOrConsonant";
        document.getElementById("prompt").innerText = "Is it a vowel?";
        return;
      }

      if (state === "vowelOrConsonant") {
        state = "vowelChoice";
        letterIndex = 0;
        document.getElementById("prompt").innerText = `Is it "${vowels[letterIndex].toUpperCase()}"?`;
        return;
      }

      if (state === "vowelChoice") {
        let letter = vowels[letterIndex];
        confirmLetter(letter);
        return;
      }

      if (state === "consonantChoice") {
        let letter = consonants[letterIndex];
        confirmLetter(letter);
        return;
      }

      if (state === "predictingNext") {
        let nextLetter = predictNextLetter(currentWord);
        if (nextLetter) confirmLetter(nextLetter);
        else updateDisplay("⚠️ No prediction available, continue manually.");
        return;
      }

      if (state === "wordComplete") {
        // YES → accept word and move to next
        currentSentence += currentWord + " ";
        currentWord = "";
        state = "vowelOrConsonant";
        document.getElementById("prompt").innerText = "Is it a vowel?";
        updateDisplay();
        return;
      }
    }

    function no() {
      if (state === "vowelOrConsonant") {
        state = "consonantChoice";
        letterIndex = 0;
        document.getElementById("prompt").innerText = `Is it "${consonants[letterIndex].toUpperCase()}"?`;
        return;
      }

      if (state === "vowelChoice") {
        letterIndex++;
        if (letterIndex < vowels.length) {
          document.getElementById("prompt").innerText = `Is it "${vowels[letterIndex].toUpperCase()}"?`;
        } else {
          updateDisplay("⚠️ No match in vowels, restarting.");
          state = "vowelOrConsonant";
        }
        return;
      }

      if (state === "consonantChoice") {
        letterIndex++;
        if (letterIndex < consonants.length) {
          document.getElementById("prompt").innerText = `Is it "${consonants[letterIndex].toUpperCase()}"?`;
        } else {
          updateDisplay("⚠️ No match in consonants, restarting.");
          state = "vowelOrConsonant";
        }
        return;
      }

      if (state === "predictingNext") {
        updateDisplay("Continuing manual spelling… Is it a vowel?");
        state = "vowelOrConsonant";
        return;
      }

      if (state === "wordComplete") {
        // NO → continue spelling longer word
        state = "predictingNext";
        askNextPrediction();
        return;
      }
    }

    function confirmLetter(letter) {
      currentWord += letter;
      let candidates = filterCandidates(currentWord);

      if (candidates.includes(currentWord)) {
        // Word fully matched
        state = "wordComplete";
        updateDisplay(`Word complete: "${currentWord}". Next word?`);
      } else {
        // Try prediction
        state = "predictingNext";
        askNextPrediction();
      }
    }

    function askNextPrediction() {
      let next = predictNextLetter(currentWord);
      if (next) {
        updateDisplay(`Is next letter "${next.toUpperCase()}"?`);
      } else {
        updateDisplay("⚠️ No prediction available. Is it a vowel?");
        state = "vowelOrConsonant";
      }
    }
  </script>
</body>
</html>








