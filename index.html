<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Eye Typing with Eye Detection</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
  body { font-family: Arial, sans-serif; text-align:center; padding:16px; max-width:600px; margin:auto;}
  h1 { font-size:28px; margin-bottom:12px; }
  #prompt { font-size:22px; margin:16px 0; min-height:60px; }
  #letter { font-size:48px; margin:16px 0; font-weight:bold; }
  #output { font-size:20px; margin:12px 0; word-break:break-word; }
  #predictions { font-size:18px; margin:8px 0; color:#222; }
  #status { font-size:16px; margin-top:6px; color:#333; }
  button { font-size:20px; padding:12px 20px; margin:6px; border:none; border-radius:8px; cursor:pointer; transition:0.15s; }
  #yesBtn { background:#28a745; color:#fff; }
  #noBtn { background:#dc3545; color:#fff; }
  #calUp, #calDown { background:#444; color:#fff; }
  .indicator { display:inline-block; width:16px; height:16px; border-radius:50%; margin-left:8px; vertical-align:middle; }
  .green { background: #28a745; } .red { background:#dc3545; } .gray { background:#bbb; }
  #webcam { display:none; width:320px; height:240px; border-radius:6px; margin-top:10px;}
  .small { font-size:14px; color:#555; margin-top:6px; }
</style>
</head>
<body>
<h1>Eye Typing Prototype â€” Eye Detection</h1>

<div id="prompt">Would you like to start?</div>
<div id="letter"> </div>
<div id="output"></div>
<div id="predictions"></div>

<div>
  <button id="yesBtn">YES</button>
  <button id="noBtn">NO</button>
</div>

<div style="margin-top:12px;">
  <button id="calUp">Calibrate Up</button>
  <button id="calDown">Calibrate Down</button>
  <span id="detectorStatus">Detector: <span id="detState">OFF</span> <span id="detIndicator" class="indicator gray"></span></span>
</div>

<div id="status" aria-live="polite"></div>
<div class="small">Use calibration before relying on eye control. Buttons always work as a fallback.</div>

<video id="webcam" autoplay playsinline></video>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/* ===================== DICTIONARY ===================== */
let dictionary = [];

// Load words.txt
fetch('words.txt')
  .then(response => response.text())
  .then(text => {
    dictionary = text.split(/\r?\n/).map(w => w.trim().toLowerCase()).filter(w => w.length > 0);
    // merge custom words
    const custom = JSON.parse(localStorage.getItem("customWords") || "[]");
    dictionary = dictionary.concat(custom);
    updateStatus(`Loaded ${dictionary.length} words from words.txt`);
  })
  .catch(err => {
    console.error('Failed to load words.txt:', err);
    updateStatus('Failed to load words.txt, using empty dictionary.');
  });

/* ===================== CONFIG ===================== */
const vowels = ["A","E","I","O","U"];
const consonants = ["T","N","S","H","R","D","L","C","M","W","F","G","Y","P","B","V","J","K","X","Q","Z"];

/* ===================== STATE ===================== */
let sentence = "";
let currentWord = "";
let step = "askStart"; // askStart | askVowel | vowel | consonant | predictLetter | askNextWord
let letterIndex = 0;
let predictedLetters = [];
let predictedIndex = 0;

/* ===================== DOM ===================== */
const promptEl = document.getElementById('prompt');
const letterEl = document.getElementById('letter');
const outputEl = document.getElementById('output');
const predsEl = document.getElementById('predictions');
const statusEl = document.getElementById('status');
const yesBtn = document.getElementById('yesBtn');
const noBtn = document.getElementById('noBtn');
const calUpBtn = document.getElementById('calUp');
const calDownBtn = document.getElementById('calDown');
const detStateEl = document.getElementById('detState');
const detIndicator = document.getElementById('detIndicator');

/* ===================== HELPERS ===================== */
function updatePrompt(t){ promptEl.innerText = t; }
function updateStatus(t){ statusEl.innerText = t; }
function updateLetter(t){ letterEl.innerText = t; }
function updateOutput(){
  outputEl.innerHTML = `<strong>Sentence:</strong> ${sentence.trim()}<br/><strong>Current word:</strong> ${currentWord}`;
  predsEl.innerHTML = predictedLetters.length ? `<strong>Predicted next letters:</strong> ${predictedLetters.join(', ')}` : '';
}
function toLower(s){ return s ? s.toLowerCase() : s; }
function computePredictedLetters(prefix){
  const p = toLower(prefix);
  const freq = {};
  for(const w of dictionary){
    if(w.startsWith(p) && w.length > p.length){
      const next = w[p.length].toUpperCase();
      freq[next] = (freq[next] || 0) + 1;
    }
  }
  return Object.entries(freq)
               .sort((a,b) => b[1]-a[1] || a[0].localeCompare(b[0]))
               .map(e=>e[0]);
}
function isExactWord(prefix){ return dictionary.includes(toLower(prefix)); }
function addWordToDictionary(word){
  word = toLower(word);
  if(!dictionary.includes(word)){
    dictionary.push(word);
    let custom = JSON.parse(localStorage.getItem("customWords") || "[]");
    custom.push(word);
    localStorage.setItem("customWords", JSON.stringify(custom));
    updateStatus(`Added new word "${word}" to dictionary (saved locally).`);
  }
}
function speakSentence(text){
  if('speechSynthesis' in window){
    const u = new SpeechSynthesisUtterance(text);
    window.speechSynthesis.speak(u);
  } else updateStatus("Speech synthesis not supported.");
}

/* ===================== CORE LOGIC ===================== */
function start(){ step="askVowel"; currentWord=""; letterIndex=0; predictedLetters=[]; predictedIndex=0; updatePrompt("Is it a vowel? (YES/NO)"); updateOutput(); updateLetter(""); }
function resetAll(){ sentence=""; currentWord=""; step="askStart"; letterIndex=0; predictedLetters=[]; predictedIndex=0; updatePrompt("Would you like to start?"); updateLetter(""); updateOutput(); updateStatus("Reset."); }
function showNextLetter(){
  const list = step==="vowel"?vowels:step==="consonant"?consonants:[]; 
  if(letterIndex < list.length){ updateLetter(list[letterIndex]); updatePrompt(`Letter: ${list[letterIndex]} ? (YES/NO)`); }
  else { step="askVowel"; updatePrompt("Reached end of list. Is it a vowel? (YES/NO)"); updateLetter(""); }
}
function addLetter(letter){
  currentWord += letter;
  updateStatus("Added letter: "+letter);
  updateOutput();
  predictedLetters = computePredictedLetters(currentWord);
  predictedIndex=0;

  if(isExactWord(currentWord)){
    step="askNextWord";
    updatePrompt(`Word is "${currentWord}". Next word? (YES to accept / NO to continue spelling)`);
  } else if(predictedLetters.length>0){
    step="predictLetter";
    updatePrompt(`Is next letter "${predictedLetters[predictedIndex]}"? (YES/NO)`);
  } else { step="askVowel"; updatePrompt("No predictions. Is it a vowel? (YES/NO)"); }
  updateOutput();
}

function handleYes(){
  switch(step){
    case "askStart": start(); break;
    case "askVowel": step="vowel"; letterIndex=0; showNextLetter(); break;
    case "vowel": addLetter(vowels[letterIndex]); break;
    case "consonant": addLetter(consonants[letterIndex]); break;
    case "predictLetter": if(predictedLetters[predictedIndex]) addLetter(predictedLetters[predictedIndex]); else { step="askVowel"; updatePrompt("Prediction missing. Is it a vowel?"); } break;
    case "askNextWord": sentence+=currentWord+" "; if(!dictionary.includes(currentWord)) addWordToDictionary(currentWord); currentWord=""; predictedLetters=[]; predictedIndex=0; step="askVowel"; updatePrompt("Next word? (YES = vowel, NO = consonant)"); updateOutput(); break;
    default: updateStatus("Unhandled YES in state: "+step);
  }
}
function handleNo(){
  switch(step){
    case "askStart": resetAll(); break;
    case "askVowel": step="consonant"; letterIndex=0; showNextLetter(); break;
    case "vowel":
    case "consonant": letterIndex++; showNextLetter(); break;
    case "predictLetter": predictedIndex++; if(predictedIndex<predictedLetters.length) updatePrompt(`Is next letter "${predictedLetters[predictedIndex]}"? (YES/NO)`); else { predictedLetters=[]; predictedIndex=0; step="askVowel"; updatePrompt("No more predicted letters. Is it a vowel?"); } break;
    case "askNextWord": if(!predictedLetters || predictedLetters.length===0){ predictedLetters=computePredictedLetters(currentWord); predictedIndex=0; } if(predictedLetters.length>0){ step="predictLetter"; updatePrompt(`Is next letter "${predictedLetters[predictedIndex]}"? (YES/NO)`); } else { step="askVowel"; updatePrompt("No predictions. Is it a vowel?"); } break;
    default: updateStatus("Unhandled NO in state: "+step);
  }
  updateOutput();
}

/* ===================== BUTTON HOOKS ===================== */
yesBtn.addEventListener('click', ()=>handleYes());
noBtn.addEventListener('click', ()=>handleNo());
calUpBtn.addEventListener('click', calibrateUp);
calDownBtn.addEventListener('click', calibrateDown);

/* ===================== FACE MESH EYE DETECTION ===================== */
let videoElement=document.getElementById('webcam');
let camera=null; let faceMesh=null;
let calibUpVal=null, calibDownVal=null;
let detectorOn=false;
let lastTriggerTime=0;
const TRIGGER_COOLDOWN=900;

function setDetectorState(on){
  detectorOn=on;
  detStateEl.innerText=on?"ON":"OFF";
  detIndicator.className="indicator "+(on?"green":"gray");
}

function computeEyeNoseDelta(landmarks){
  if(!landmarks || landmarks.length<400) return null;
  const leftCenterY=(landmarks[159].y+landmarks[145].y)/2;
  const rightCenterY=(landmarks[386].y+landmarks[374].y)/2;
  const eyeCenterY=(leftCenterY+rightCenterY)/2;
  const nose=landmarks[1]||landmarks[4];
  return nose.y-eyeCenterY;
}

async function initFaceMesh(){
  faceMesh=new FaceMesh({locateFile:(file)=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
  faceMesh.setOptions({maxNumFaces:1,refineLandmarks:true,minDetectionConfidence:0.6,minTrackingConfidence:0.6});
  faceMesh.onResults(onFaceMeshResults);
  camera=new Camera(videoElement,{onFrame:async()=>{await faceMesh.send({image:videoElement});},width:640,height:480});
}

function onFaceMeshResults(results){
  if(!results.multiFaceLandmarks || results.multiFaceLandmarks.length===0){ updateStatus("Face not detected"); return; }
  updateStatus("Face detected");
  const landmarks=results.multiFaceLandmarks[0];
  window.__lastFaceLandmarks=landmarks;
  const delta=computeEyeNoseDelta(landmarks);
  if(delta===null) return;
  if(calibUpVal===null || calibDownVal===null){ detIndicator.className="indicator gray"; detStateEl.innerText="CALIBRATE"; return; }
  setDetectorState(true);
  const mid=(calibUpVal+calibDownVal)/2;
  const range=Math.abs(calibUpVal-calibDownVal);
  const upThresh=mid+(range*0.15);
  const downThresh=mid-(range*0.15);
  const now=Date.now();
  if(delta>upThresh && now-lastTriggerTime>TRIGGER_COOLDOWN){ lastTriggerTime=now; detIndicator.className="indicator green"; detStateEl.innerText="LOOK UP â†’ YES"; handleYes(); }
  else if(delta<downThresh && now-lastTriggerTime>TRIGGER_COOLDOWN){ lastTriggerTime=now; detIndicator.className="indicator red"; detStateEl.innerText="LOOK DOWN â†’ NO"; handleNo(); }
  else { detIndicator.className="indicator gray"; detStateEl.innerText="IDLE"; }
}

/* ===================== CALIBRATION ===================== */
function collectDeltaSamples(frameCount=20, intervalMs=60){
  return new Promise((resolve,reject)=>{
    const samples=[]; let collected=0; let tries=0; const maxTries=frameCount*5;
    const t=setInterval(()=>{
      tries++;
      if(window.__lastFaceLandmarks){
        const delta=computeEyeNoseDelta(window.__lastFaceLandmarks);
        if(delta!==null){ samples.push(delta); collected++; }
      }
      if(collected>=frameCount || tries>maxTries){ clearInterval(t); if(samples.length===0) reject("no face samples"); else resolve(samples.reduce((a,b)=>a+b,0)/samples.length); }
    },intervalMs);
  });
}
function calibrateUp(){ if(!faceMesh){ updateStatus("Start camera first."); return; } updateStatus("Calibrating UP..."); collectDeltaSamples(20,40).then(avg=>{ calibUpVal=avg; updateStatus(`Calibrated UP: ${avg.toFixed(4)}`); if(calibDownVal!==null) detStateEl.innerText="CALIBRATED"; }).catch(e=>updateStatus("Calibration failed: "+e)); }
function calibrateDown(){ if(!faceMesh){ updateStatus("Start camera first."); return; } updateStatus("Calibrating DOWN..."); collectDeltaSamples(20,40).then(avg=>{ calibDownVal=avg; updateStatus(`Calibrated DOWN: ${avg.toFixed(4)}`); if(calibUpVal!==null) detStateEl.innerText="CALIBRATED"; }).catch(e=>updateStatus("Calibration failed: "+e)); }

/* ===================== INIT ===================== */
resetAll();
initFaceMesh();
if(camera) camera.start();
</script>
</body>
</html>






